{"type": "root", "attrs": {}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Writing a custom viewport shader in GLSL"], "extent": [0, 45]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [45, 61], "body": [{"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [61, 68], "body": [{"type": "para", "indent": 4, "text": ["Custom GLSL shaders aren\u2019t supported for Vulkan. Instead, use ", {"scheme": null, "value": "/solaris/materialx", "type": "link", "text": ["MaterialX"], "fullpath": "/solaris/materialx.html"}, "."], "extent": [89, 188]}], "container": true, "attrs": {"id": "custom_glsl"}}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["OpenGL shaders are written using GLSL (the OpenGL Shader Language). Before you can create an OpenGL shader you need to understand GLSL and its related concepts such as vertex shaders and fragment shaders."], "extent": [188, 394]}, {"type": "para", "indent": 0, "text": ["It is much easier to use the built-in viewport shader and ", {"scheme": null, "value": "opengl", "type": "link", "text": ["tag parameters in your material"], "fullpath": "/shade/opengl.html"}, " as various OpenGL properties. However, if you want to write your own custom GLSL shader instead, you can use the information below."], "extent": [394, 626]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "http://opengl.org/documentation/glsl/", "type": "link", "text": ["the OpenGL GLSL documentation"], "exists": true}, " for more information on programming in GLSL."], "extent": [626, 747]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Creating a new GLSL shader node"], "extent": [747, 785], "body": [{"type": "para", "indent": 0, "text": ["Creating a GLSL shader requires creating a new VOP type. Currently you cannot create a GLSL shader using VOPs."], "extent": [785, 898]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 0, "role": "item", "extent": [898, 903], "body": [{"type": "para", "indent": 4, "text": ["Alternatively you can store the GLSL shader source in a text file and reference the filename on your material using the ", {"scheme": null, "value": "/props/material#ogl_glsl_shader", "type": "link", "text": ["ogl_glsl_shader"], "fullpath": "/props/material.html#ogl_glsl_shader", "fragment": "#ogl_glsl_shader"}, " property."], "extent": [903, 1088]}], "container": true}], "container": true, "role": "item_group"}, {"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["Choose ", {"type": "ui", "text": ["File \u25b8 New operator type"]}, "."], "extent": [1088, 1128]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Click on ", {"type": "ui", "text": ["VOP Type"]}, "."], "extent": [1128, 1154]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["In the ", {"type": "ui", "text": ["Network Type"]}, " menu, choose ", {"type": "ui", "text": ["GLSL Shader"]}, "."], "extent": [1154, 1211]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Enter an internal ", {"type": "ui", "text": ["Name"]}, " for the shader and a human-readable ", {"type": "ui", "text": ["Label"]}, "."], "extent": [1211, 1288]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Click ", {"type": "ui", "text": ["Accept"]}, ". The ", {"scheme": null, "value": "/ref/windows/optype", "type": "link", "text": ["type properties window"], "fullpath": "/ref/windows/optype.html"}, " for the new shader type appears."], "extent": [1288, 1391]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Click the ", {"type": "ui", "text": ["Code"]}, " tab. The node starts with some default shader code. You can use this as a starting point for creating your shader."], "extent": [1391, 1528], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "ui", "text": ["Code"]}, " tab provides a simple editor for working with GLSL code. The editor has four text boxes: one for the vertex shader, one for an optional geometry shader, one for the fragment shader, and one for compiler output. You can drag the dividers between the three panes to resize them or maximize a single pane."], "extent": [1528, 1853]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Click ", {"type": "ui", "text": ["Test compile"]}, " to try compiling the default code. The output of the compiler appears in the third pane."], "extent": [1853, 1969]}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Applying an OpenGL shader"], "extent": [1969, 2001], "body": [{"type": "task_group", "body": [{"ext": null, "type": "task", "indent": 0, "text": [" Assign a GLSL shader for the viewport only"], "role": "item", "extent": [2001, 2053], "body": [{"type": "para", "indent": 4, "text": ["Set an object\u2019s surface shader to an instance of your GLSL shader, or connect an instance of your GLSL shader to the surface color output inside a material."], "extent": [2053, 2215]}], "container": true}, {"ext": null, "type": "task", "indent": 0, "text": [" Assign both a GLSL shader for the viewport and a shader for the renderer"], "role": "item", "extent": [2215, 2296], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["You can define both GLSL shader code and VEX or RenderMan code in a GLSL shader type. Houdini will use the GLSL code in the viewport and the VEX/RenderMan code in the render."], "extent": [2296, 2482], "body": [{"type": "para", "indent": 8, "text": ["On the ", {"type": "ui", "text": ["Code"]}, " tab, click the ", {"scheme": "Icon", "value": "BUTTONS/gear", "type": "link", "text": "", "fullpath": "/shade/BUTTONS/gear.html"}, " gear menu and turn on ", {"type": "ui", "text": ["VEX/RenderMan shader"]}, ". This creates another tab where you can write VEX or RenderMan shader code."], "extent": [2482, 2673]}], "container": true}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["You can also connect both an OpenGL shader and VEX surface shader to the surface color output of a material using a ", {"scheme": "Node", "value": "/nodes/shop/select", "type": "link", "text": ["Select shader node"], "fullpath": "/nodes/shop/select.html"}, "."], "extent": [2673, 2835]}], "container": true}], "container": true}, {"ext": null, "type": "task", "indent": 0, "text": [" Assign a custom GLSL shader to an existing material"], "role": "item", "extent": [2835, 2895], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["Add the GLSL Shader parameter using ", {"type": "ui", "text": ["Edit Rendering Parameters"]}, " in the ", {"scheme": "Icon", "value": "BUTTONS/gear", "type": "link", "text": "", "fullpath": "/shade/BUTTONS/gear.html"}, " gear menu on the material\u2019s parameter dialog. The parameter is in the SHOP/OGL sub folder."], "extent": [2895, 3086]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["Enter the filename of a program description file (.prog) or a whitespace separated list of shader files. The format of a program file is documented above. The file extension of a shader file defines its shader stage:"], "extent": [3086, 3309], "body": [{"type": "bullet_group", "body": [{"blevel": 10, "type": "bullet", "indent": 8, "text": [{"type": "code", "text": [".vert"]}, ": vertex shader"], "extent": [3309, 3342]}, {"blevel": 10, "type": "bullet", "indent": 8, "text": [{"type": "code", "text": [".frag"]}, ": fragment shader"], "extent": [3342, 3377]}, {"blevel": 10, "type": "bullet", "indent": 8, "text": [{"type": "code", "text": [".geom"]}, ": geometry shader"], "extent": [3377, 3412]}, {"blevel": 10, "type": "bullet", "indent": 8, "text": [{"type": "code", "text": [".tcs"]}, ": tessellation control shader (GL4.0+)"], "extent": [3412, 3467]}, {"blevel": 10, "type": "bullet", "indent": 8, "text": [{"type": "code", "text": [".tes"]}, ": tessellation evaluation shader (GL4.0+)"], "extent": [3467, 3527]}], "container": true}], "container": true}], "container": true}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Houdini built-in functions"], "extent": [3527, 3560], "body": [{"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Fragment shader functions"], "extent": [3560, 3595], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["void HOUassignLitOutput(vec3 point_color,vec3 emit,vec3 amb,vec3 diff,vec3 spec,vec4 wire,float alpha,float selected)"]}], "extent": [3595, 3717], "body": [{"type": "para", "indent": 5, "text": ["Composites the lighting components, applies any Houdini shading (such as \n     ghosting), and assigns the result to the fragment shader out in normal \n     lighting mode (", {"type": "code", "text": ["glH_MaterialPass"]}, " is 0). The normal renderer is a forward\n     renderer (all lighting computed on all shaded pixels)."], "extent": [3717, 4013]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["void HOUassignMaterialOutput(vec3 point_color,vec3 emit_color,vec3 amb_color,vec3 diff_color,vec3 spec_color,float alpha,float emit_alpha,float shiny,vec4 wire,vec3 nN,float z,float selected)"]}], "extent": [4013, 4208], "body": [{"type": "para", "indent": 5, "text": ["Assigns the lighting components to the g-buffer outputs for the high\n     quality lighting mode (", {"type": "code", "text": ["glH_MaterialPass"]}, " is 1). The High Quality lighting\n     renderer is a deferred shading renderer (all parameters required for \n     lighting and shading is stored in multiple buffers, and lights are \n     processed after all geometry is rendered). "], "extent": [4208, 4560]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["void HOUapplyLightMaps(inout vec3 nN, inout vec3 mspec, inout float shiny,bool has_bump_map, bool has_spec_map, vec2 bumpCoords, vec2 specCoords, float bumpScale, int bumpComps, bool bumpBias, bool bumpInvert, vec2 bumpMapSize, bool specularShinyAdjust, vec2 shinyRange)"]}], "extent": [4560, 4834], "body": [{"type": "para", "indent": 5, "text": ["Computes the normal (", {"type": "code", "text": ["nN"]}, "), material specular color component (", {"type": "code", "text": ["mspec"]}, ") and \n     material shininess (", {"type": "code", "text": ["shiny"]}, ") from the specular, bump and normal maps."], "extent": [4834, 4992]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["void HOUfastLightingModel(in vec3 P,in vec3 nN,inout vec3 lAmb,inout vec3 lDiff,inout vec3 lSpec,in float sh)"]}], "extent": [4992, 5106], "body": [{"type": "para", "indent": 5, "text": ["Computes the lighting components ", {"type": "code", "text": ["aAmb"]}, ", ", {"type": "code", "text": ["lDiff"]}, ", and ", {"type": "code", "text": ["lSpec"]}, " (ambient, \n     diffuse and specular) using the first 3 scene lights (or headlight). This \n     should only be used when rendering normal lighting (", {"type": "code", "text": ["glH_MaterialPass"]}, " is \n     0)."], "extent": [5106, 5354]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["void HOUlightingModel(in vec3 P,in vec3 nN,inout vec3 lAmb,inout vec3 lDiff,inout vec3 lSpec,in float sh)"]}], "extent": [5354, 5463], "body": [{"type": "para", "indent": 5, "text": ["Computes the lighting components in the same way as ", {"type": "code", "text": ["HOUfastLightingModel"]}, "\n     but for the first 9 scene lights (or headlight). This should only be used \n     when rendering normal lighting (", {"type": "code", "text": ["glH_MaterialPass"]}, " is 0)."], "extent": [5463, 5687]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["float HOUwireAlpha(vec3 edgedist, int edgeflag, float cut)"]}], "extent": [5687, 5749], "body": [{"type": "para", "indent": 5, "text": ["Given the edge distances and flags for all 3 triangle edges (x,y,z), and \n     cutoff tolerance for the inner (non-AA) section of the line, compute an \n     alpha for a pixel within a rendered triangle. This creates outlined \n     triangles based on ", {"type": "code", "text": ["glH_WireThickness"]}, "."], "extent": [5749, 6026]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["vec4 HOUwireColor(vec3 edgedist, int edgeflag, float selected)"]}], "extent": [6026, 6092], "body": [{"type": "para", "indent": 5, "text": ["Similar to ", {"type": "code", "text": ["HOUwireAlpha()"]}, ", this computes the wire color and AA for \n     outlining a triangle. The selected parameter allows mixing between the \n     ", {"type": "code", "text": ["glH_SelectionColor"]}, " and the ", {"type": "code", "text": ["glH_WireColor"]}, "."], "extent": [6092, 6297]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Geometry shader functions"], "extent": [6297, 6331], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["vec3 HOUedgeDistance(vec4 v0, vec4 v1, vec4 v2, out int edges))"]}], "extent": [6331, 6399], "body": [{"type": "para", "indent": 5, "text": ["Given the three vertices in clip space of a triangle within a tessellated \n     polygon, compute the edge flags (", {"type": "code", "text": ["edges"]}, ") and edge distances (return value)\n     to be used by ", {"type": "code", "text": ["HOUwireColor()"]}, " or ", {"type": "code", "text": ["HOUwireAlpha()"]}, " in the fragment shader.\n     The edge distances are in screen pixels. The edge flags are bits in the \n     integer which indicate if that edge is an interior edge (zero, crosses the\n     polygon) or an exterior edge (one, lies along a polygon edge). The edge bits\n     are 1 (v1-v2), 2 (v0-v2) and 4 (v0-v1)."], "extent": [6399, 6931]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["int HOUedges(vec4 v0, vec4 v1, vec4 v2)"]}], "extent": [6931, 6974], "body": [{"type": "para", "indent": 5, "text": ["A stripped down version of ", {"type": "code", "text": ["HOUedgeDistance()"]}, ", this only returns the edge\n     flags for the triangle within a tessellated polygon. "], "extent": [6974, 7114]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["bool HOUfrustumCull(vec4 v0, vec4 v1, vec4 v2)"]}], "extent": [7114, 7164], "body": [{"type": "para", "indent": 5, "text": ["Returns true if the triangle with vertices v0, v1 and v2 (in clip space)\n     is outside the current viewing frustum. This is a fast check, and some \n     cases which are actually outside the viewing frustum may return false. In \n     no cases will a triangle that is within the viewing frustum ever return \n     true."], "extent": [7164, 7489]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["int HOUprimitiveID(out ivec3 vertices)"]}], "extent": [7489, 7531], "body": [{"type": "para", "indent": 5, "text": ["Returns the primitive ID for the current triangle, line or point. The \n     ", {"type": "code", "text": ["vertices"]}, " parameter returns the vertex indices for accessing vertex \n     attributes stored within a texture or texture buffer object."], "extent": [7531, 7749]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["int HOUprimitiveIDEdges(out ivec3 vertices, out int edgeflags)"]}], "extent": [7749, 7815], "body": [{"type": "para", "indent": 5, "text": ["This is a combination of ", {"type": "code", "text": ["HOUprimitiveID()"]}, " and ", {"type": "code", "text": ["HOUedges()"]}, ". It returns the \n     primitive index and vertices' indices as in ", {"type": "code", "text": ["HOUprimitiveID()"]}, ", and the edge\n     flags as in ", {"type": "code", "text": ["HOUedges()"]}, ". It is slightly faster than calling both. "], "extent": [7815, 8054]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["int HOUvertexID(out ivec3 vertices)"]}], "extent": [8054, 8093], "body": [{"type": "para", "indent": 5, "text": ["Returns a bitfield that provides some information about the current \n     triangle, and sets ", {"type": "code", "text": ["vertices"]}, " to the local vertex numbers of the polygon\n     (always in the range zero to number of polygon vertices minus one). This is\n     different from the ", {"type": "code", "text": ["vertices"]}, " parameter in ", {"type": "code", "text": ["HOUprimitiveID()"]}, ", which returns\n     the vertex offsets within an attribute (zero to number of detail vertices \n     minus one). The returned bitfield provides the following polygon \n     tessellation information for the current triangle:"], "extent": [8093, 8616]}, {"type": "bullet_group", "body": [{"blevel": 7, "type": "bullet", "indent": 5, "text": ["0\u00d701:  first triangle in the polygon"], "extent": [8616, 8660]}, {"blevel": 7, "type": "bullet", "indent": 5, "text": ["0\u00d702:  middle triangle in the polygon"], "extent": [8660, 8705]}, {"blevel": 7, "type": "bullet", "indent": 5, "text": ["0\u00d704:  last triangle in the polygon"], "extent": [8705, 8748]}, {"blevel": 7, "type": "bullet", "indent": 5, "text": ["0\u00d708:  polygon has an odd number of triangles"], "extent": [8748, 8801]}, {"blevel": 7, "type": "bullet", "indent": 5, "text": ["0\u00d710:  vertex 1 has not already been used in this polygon"], "extent": [8801, 8866]}, {"blevel": 7, "type": "bullet", "indent": 5, "text": ["0\u00d720:  vertex 2 has not already been used in this polygon"], "extent": [8866, 8931]}, {"blevel": 7, "type": "bullet", "indent": 5, "text": ["0\u00d740:  vertex 3 has not already been used in this polygon"], "extent": [8931, 8997]}], "container": true}, {"type": "para", "indent": 5, "text": ["This can be used to position primitive and vertex decorations and estimate\n     the centroid of the polygon."], "extent": [8997, 9113]}], "container": true}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Houdini auto-uniforms"], "extent": [9113, 9143], "body": [{"type": "para", "indent": 0, "text": ["Houdini automatically generates values for the following uniforms (all prefixed\nwith ", {"type": "code", "text": ["glH_"]}, ") which may be used by all shader stages."], "extent": [9143, 9278]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_MaterialPass"]}], "extent": [9278, 9298], "body": [{"type": "para", "indent": 4, "text": ["An integer that stores the current pass being render. These passes are:"], "extent": [9298, 9375]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["0 - normal lighting pass"], "extent": [9375, 9406]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["1 - high quality lighting pass"], "extent": [9406, 9443]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["3 - shadow map pass"], "extent": [9443, 9470]}], "container": true}, {"type": "para", "indent": 4, "text": ["Lighting calculations should only be performed if ", {"type": "code", "text": ["glH_MaterialPass"]}, " is 0.\n    Basic material properties (diffuse, ambient, specular and emission) only\n    need to be provided for pass #1. Pass #3 only requires alpha and depth.\n    Pass #2 was deprecated with the old H11 viewport."], "extent": [9470, 9757]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_ViewMatrix"]}], "extent": [9757, 9775], "body": [{"type": "para", "indent": 4, "text": ["The view matrix (not to be confused with OpenGL\u2019s ", {"type": "code", "text": ["modelview"]}, " matrix). The\n    view matrix is only the viewport tumble transform, as the object resides \n    in ", {"type": "code", "text": ["glH_ObjectMatrix"]}, "."], "extent": [9775, 9960]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_InvViewMatrix"]}], "extent": [9960, 9981], "body": [{"type": "para", "indent": 4, "text": ["The inverse of the view matrix (not to be confused with OpenGL\u2019s ", {"type": "code", "text": ["modelview"]}, " matrix)."], "extent": [9981, 10072]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_ObjectMatrix"]}], "extent": [10072, 10092], "body": [{"type": "para", "indent": 4, "text": ["The object transform for the geometry."], "extent": [10092, 10136]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_ProjectMatrix"]}], "extent": [10136, 10157], "body": [{"type": "para", "indent": 4, "text": ["The transform used to convert camera space coords to clip space\n    coords (which are ", {"type": "code", "text": ["[-1,1]"]}, " for X,Y, and Z)."], "extent": [10157, 10274]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_InvProjectMatrix"]}], "extent": [10274, 10298], "body": [{"type": "para", "indent": 4, "text": ["The inverse of the projection matrix, used to convert clip coords back into\n    camera space."], "extent": [10298, 10397]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_NumSamples"]}], "extent": [10397, 10415], "body": [{"type": "para", "indent": 4, "text": ["The number of samples in a multisampled (2x, 4x, 8\u00d7 AA) buffer. "], "extent": [10415, 10489]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_LightingEnabled"]}], "extent": [10489, 10512], "body": [{"type": "para", "indent": 4, "text": ["An integer that is either 1 if lighting is enabled, or zero if not."], "extent": [10512, 10585]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_LightMask"]}], "extent": [10585, 10602], "body": [{"type": "para", "indent": 4, "text": ["A int32 bitmask of lights that are enabled. The first scene light has \n    bit 1, the second bit 2 (0\u00d72), the third bit 3 (0\u00d74), etc."], "extent": [10602, 10741]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_ScreenSize"]}], "extent": [10741, 10759], "body": [{"type": "para", "indent": 4, "text": ["A vec2 containing the current dimension of the viewport being rendered."], "extent": [10759, 10836]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_WireOver"]}], "extent": [10836, 10852], "body": [{"type": "para", "indent": 4, "text": ["An integer set to one when a wireframe should be drawn over the model, and \n    zero otherwise."], "extent": [10852, 10953]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_WireColor"]}], "extent": [10953, 10970], "body": [{"type": "para", "indent": 4, "text": ["The constant color of the wireframe overlay. This can change colors based on\n    selection, template drawing or ghosting."], "extent": [10970, 11097]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_WireThickness"]}], "extent": [11097, 11118], "body": [{"type": "para", "indent": 4, "text": ["The current wire thickness, based on the display option setting, which may\n    change depending on the selection status."], "extent": [11118, 11244]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_ConstColor"]}], "extent": [11244, 11262], "body": [{"type": "para", "indent": 4, "text": ["The constant color for drawing modes such as Hidden Line Invisible and Ghost."], "extent": [11262, 11345]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_IsOrtho"]}], "extent": [11345, 11360], "body": [{"type": "para", "indent": 4, "text": ["An integer set to zero if the view is perspective, or one if orthographic."], "extent": [11360, 11440]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_SelectMode"]}], "extent": [11440, 11458], "body": [{"type": "para", "indent": 4, "text": ["The current component selection display mode:"], "extent": [11458, 11509]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["0: nothing selected"], "extent": [11509, 11535]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["1: primitives, some selected"], "extent": [11535, 11570]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["2: primitives, all selected"], "extent": [11570, 11604]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["3: points, some selected"], "extent": [11604, 11635]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["4: points, all selected"], "extent": [11635, 11665]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["5: vertices: some selected"], "extent": [11665, 11698]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["6: vertices: all selected"], "extent": [11698, 11731]}], "container": true}, {"type": "para", "indent": 4, "text": ["Point, primitive and vertex group selections are treated as point, primitive\n    and vertex selections, respectively."], "extent": [11731, 11855]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["The follow uniforms are available, but generally only used by the ", {"type": "code", "text": ["HOUassign()"]}, " family of built-in Houdini functions. If you do not use them (not recommended) you will need to multiply in the factors, apply the ghost color, handle selection highlights, and two-sided lighting for transparency."], "extent": [11855, 12150]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_Emission"]}], "extent": [12150, 12166], "body": [{"type": "para", "indent": 4, "text": ["A float that is 1.0 if emission is used in this pass, 0.0 if not."], "extent": [12166, 12237]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_Specular"]}], "extent": [12237, 12253], "body": [{"type": "para", "indent": 4, "text": ["A float that is 1.0 if specular is used in this pass, 0.0 if not."], "extent": [12253, 12324]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_Diffuse"]}], "extent": [12324, 12339], "body": [{"type": "para", "indent": 4, "text": ["A float that is 1.0 if diffuse is used in this pass, 0.0 if not."], "extent": [12339, 12409]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_Ambient"]}], "extent": [12409, 12424], "body": [{"type": "para", "indent": 4, "text": ["A float that is 1.0 if ambient is used in this pass, 0.0 if not."], "extent": [12424, 12494]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_GhostColor"]}], "extent": [12494, 12512], "body": [{"type": "para", "indent": 4, "text": ["A vec4 representing the ghosting color for 'ghost other objects' display\n    mode. It is set regardless of whether the current object is ghosted, though\n    the color will be (0,0,0,0) if the object is not ghosted."], "extent": [12512, 12732]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_SelectColor"]}], "extent": [12732, 12751], "body": [{"type": "para", "indent": 4, "text": ["The current selection color, which can change depending on the selection\n    type (object, component, closure, secondary). "], "extent": [12751, 12880]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["glH_AlphaPass"]}], "extent": [12880, 12897], "body": [{"type": "para", "indent": 4, "text": ["An integer that is 1 when a transparency pass is active, 0 otherwise.\n    Transparency passes always light the polygon face that is facing the light.\n    This is used by the ", {"type": "code", "text": ["HOUlightingModel()"]}, ", ", {"type": "code", "text": ["HOUdiffuse()"]}, " and ", {"type": "code", "text": ["HOUlightDiffSpec()"]}, " lighting methods."], "extent": [12897, 13157]}], "container": true}], "container": true}]}, {"level": 3, "id": "guidelines", "container": true, "type": "h", "indent": 0, "text": ["Coding guidelines"], "extent": [13157, 13196], "body": [{"type": "para", "indent": 0, "text": ["Houdini\u2019s viewport renderer has a large number of display settings which users can change. In some cases the viewport renderer renders multiple passes in order to create a certain visual effect. For example, projective textures and shadows both require multiple passes."], "extent": [13196, 13468]}, {"type": "para", "indent": 0, "text": ["To be compatible with Houdini\u2019s various rendering modes, GLSL shaders should adhere to the following guidelines:"], "extent": [13468, 13582]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Use one of the ", {"type": "code", "text": ["HOUassign...()"]}, " methods to assign the color output of a fragment\n  shader."], "extent": [13582, 13676]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Do GL lighting with ", {"type": "code", "text": ["HOUlightingModel()"]}, ", ", {"type": "code", "text": ["HOUdiffuse()"]}, " or ", {"type": "code", "text": ["HOUlightDiffSpec()"]}, ".\n  Otherwise, only add light contributions from enabled light sources. \n  Use the ", {"type": "code", "text": ["glH_LightEnabled"]}, " or ", {"type": "code", "text": ["glH_LightMask"]}, " uniform to check which lights \n  are enabled."], "extent": [13676, 13927]}], "container": true}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["The multi-pass viewport render"], "extent": [13927, 13966], "body": [{"type": "para", "indent": 0, "text": ["When writing a GLSL shader in Houdini it is useful to understand the contexts \nin which the shader will be executed. The uniform ", {"type": "code", "text": ["glH_MaterialPass"]}, " can be used to query the pass."], "extent": [13966, 14147]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Normal Lighting Pass (0)"], "extent": [14147, 14173], "body": [{"type": "para", "indent": 4, "text": ["Ambient, diffuse, specular and emission components can all be calculated\n    with full lighting. This may be done with the Houdini lighting functions or\n    by the shader."], "extent": [14173, 14350]}], "container": true}, {"type": "dt", "indent": 0, "text": ["High Quality Lighting Pass (1)"], "extent": [14350, 14382], "body": [{"type": "para", "indent": 4, "text": ["The raw ambient, diffuse, specular and emissive components of the material\n    should be defined but no lighting calculations should be applied. If a \n    shader does not want to participate in HQ lighting, do the lighting \n    computations and assign it to the emissive component."], "extent": [14382, 14669]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["Pass value #2 is obsolete."], "extent": [14669, 14697]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Shadow Map Pass (3)"], "extent": [14697, 14718], "body": [{"type": "para", "indent": 4, "text": ["A shadow map is being created. Only the depth and alpha value are used, so\n    all calculations for color can be avoided."], "extent": [14718, 14846]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["When shading, the ", {"type": "code", "text": ["glH_AlphaPass"]}, " variable is set to 1 if a transparency pass\nis rendering. You may discard the fragment if your material uses transparency\nand ", {"type": "code", "text": ["glH_AlphaPass"]}, " is 0, or if your material is opaque and ", {"type": "code", "text": ["glH_AlphaPass"]}, " is 1."], "extent": [14846, 15086]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Transparency"], "extent": [15086, 15107], "body": [{"type": "para", "indent": 0, "text": ["The OpenGL viewport renderer distinguishes between transparent and opaque \nmaterials. To properly render transparent objects, shaders must provide a hint \nto the renderer if the transparency is not derived from the diffuse or opacity\ntexture, the ", {"type": "code", "text": ["ogl_alpha"]}, " or ", {"type": "code", "text": ["ogl_alpha_perp"]}, " parameters, or the ", {"type": "code", "text": ["Alpha"]}, " geometry\nattribute. Add the ", {"type": "code", "text": ["ogl_alpha_shader"]}, " parameter to the material, VOP, or SHOP to\nensure the material receives an alpha pass (Edit Rendering Parameters, \nSHOP / OGL)."], "extent": [15107, 15591]}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["OpenGL GL 3.3 Core Principals"], "extent": [15591, 15627], "body": [{"type": "para", "indent": 0, "text": ["The viewport pushes many responsibilities to the GPU, in order to improve\ngeometry update performance. This makes parts of the shaders a bit more \ncomplicated, such as the geometry shader. The geometry shader is required to \nlookup primitive and vertex attributes (the vertex shader can only lookup vertex\nattributes)."], "extent": [15627, 15948]}, {"type": "para", "indent": 0, "text": ["In addition, the GLSL built-ins are deprecated. These include the GL lighting \nuniforms, transform matrices (", {"type": "code", "text": ["gl_ProjectionMatrix"]}, ", ", {"type": "code", "text": ["gl_ModelviewMatrix"]}, "), and\nthe predefined vertex shader inputs and outputs (", {"type": "code", "text": ["glVertex"]}, ", ", {"type": "code", "text": ["glNormal"]}, ", ", {"type": "code", "text": ["glColor"]}, ", \n", {"type": "code", "text": ["gl_MultiTexCoord#"]}, ", ", {"type": "code", "text": ["gl_TexCoord[]"]}, "). Instead, all information is passed through\nuniforms, uniform blocks, and named vertex inputs (", {"type": "code", "text": ["P"]}, ", ", {"type": "code", "text": ["Cd"]}, ", ", {"type": "code", "text": ["Alpha"]}, ", ", {"type": "code", "text": ["N"]}, ") which \ncorrespond to their Houdini attribute names."], "extent": [15948, 16403]}, {"type": "para", "indent": 0, "text": ["Besides the ", {"type": "code", "text": ["glH_"]}, " Houdini uniforms listed above, the viewport also \nrecognizes uniform blocks. There are a limited number of uniform blocks \navailable in any shader stage (see ", {"type": "ui", "text": ["Help \u25b8 About Houdini"]}, " and Show Details, \nin the OpenGL information for COMBINED_VERT_UNIFORM_BLOCKS and others). "], "extent": [16403, 16699]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Material uniform block"], "extent": [16699, 16730], "body": [{"type": "para", "indent": 0, "text": ["The definition of a Houdini material. This may be used in any shader stage."], "extent": [16730, 16808]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nlayout(std140) uniform material\n{\n    vec3            ambient_color;\n    vec3            diffuse_color;\n    vec3            emission_color;\n    vec3            specular_color;\n    float           material_alpha;\n    float           material_alpha_parallel;\n    float           shininess;\n    bool            has_diffuse_map;\n    \n    bool            has_bump_map;\n    int             bumpComps;\n    vec2            bumpMapSize;\n    bool            bumpBias;\n    bool            bumpInvert;\n    float           bumpScale;\n    \n    bool            has_spec_map;\n    bool            specularShinyAdjust;\n    vec2            shinyRange;\n    \n    bool            has_env_map;\n    float           envScale;\n    mat3            envRotate;\n};\n\nuniform sampler2D diffuseMap;\nuniform sampler2D bumpMap;\nuniform sampler2D specularMap;\n"], "extent": [16808, 17640]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Light uniform block"], "extent": [17640, 17670], "body": [{"type": "para", "indent": 0, "text": ["Basic information for scene lights. The trailing digit may be 0-9 for multiple\nlights. Check the glH_LightMask to see if that light should contribute."], "extent": [17670, 17823]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nlayout(std140) uniform light0\n{\n    vec3        pos;\n    vec3        dir;\n    vec3        atten;\n    vec3        amb;\n    vec3        spec;\n    vec3        diff;\n    float       coscutoff;\n    bool        point;\n} lightSource0;\n"], "extent": [17823, 18059]}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Program file format"], "extent": [18059, 18087], "body": [{"type": "para", "indent": 0, "text": ["Houdini can load custom shaders using a .prog file. The .prog format is a \ntext-based list of directives and files. Here is an example:"], "extent": [18087, 18225]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\n#name Simple Surface Shader\n\n#version 150\n#input P 0\n#input N 1\n#input Cd 2\n#input Alpha 3\n#output color 0\n\nsurface/simple.vert\nsurface/simple.frag\n"], "extent": [18225, 18381]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["#name"]}, " directive gives the shader a descriptive name. This is optional; otherwise the .prog filename will be the shader\u2019s name."], "extent": [18381, 18516]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["#version"]}, " directive defines the GLSL version this shader uses. This is the same as the GLSL directive, except that ", {"type": "code", "text": ["core"]}, ", ", {"type": "code", "text": ["compatibility"]}, ", and ", {"type": "code", "text": ["es"]}, " modifiers are not allowed. It may be defined multiple times, each time with a different value defining a separate set of files to load. The highest version supported by the implementation will be loaded. At least one ", {"type": "code", "text": ["#version"]}, " directive must exist, before any shader files are specified."], "extent": [18516, 18960]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["#extension"]}, " directive defines a OpenGL extension that must be present in order for the shader set to be accepted. The parameter must be the exact name of the GL extension to use, such as ", {"type": "code", "text": ["GL_ARB_sample_shading"]}, " or ", {"type": "code", "text": ["GL_EXT_framebuffer_object"]}, ". Multiple ", {"type": "ui", "text": ["#extensions"]}, " may be specified for the same shader set, and all of them must be present in order for the set to be loaded. A new ", {"type": "code", "text": ["#version"]}, " directive will clear the list of required extensions."], "extent": [18960, 19414]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["#input"]}, " directive binds generic vertex attributes to specific attribute indices. Only generic vertex attributes can be assigned (no GL-builtins with the gl_ prefix may be bound), and only to valid indices (from 0 to the maximum GL-supported index, usually 15). This provides a similar function to the ", {"type": "code", "text": ["GL_ARB_explicit_attribute_location"]}, " extension. These are optional, must be specified after a ", {"type": "ui", "text": ["#version"]}, " directive, and are cleared when a new ", {"type": "ui", "text": ["#version"]}, " directive is encountered."], "extent": [19414, 19905]}, {"type": "para", "indent": 0, "text": ["There is also a ", {"type": "code", "text": ["#hou_attrib_map"]}, " directive, which assigns attributes known to Houdini to standard binding locations:"], "extent": [19905, 20024]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nP = 0 (vec3)\nCd = 1 (vec3)\nAlpha = 2 (float)\nN = 3 (vec3)\nuv = 4 (vec2)\npointScale = 5 (float)\npointSelection = 6 (int)\npointID = 7 (int)\ninstIndex = 8 (int)\n"], "extent": [20024, 20190]}, {"type": "para", "indent": 0, "text": ["All other generic attributes are assigned starting at attribute location 9."], "extent": [20190, 20268]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["#output"]}, " directive binds named fragment shader outputs to specific draw buffer indices. This is optional, must appear after a ", {"type": "ui", "text": ["#version"]}, " directive and is cleared when another ", {"type": "ui", "text": ["#version"]}, " directive is encountered. This is useful for shaders that output more than one value to different draw buffers/textures."], "extent": [20268, 20585]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["#define"]}, " directive passes a defined symbol to the shader. "], "extent": [20585, 20650]}, {"type": "para", "indent": 0, "text": ["The shader files themselves are loaded from the ", {"type": "code", "text": ["HOUDINI_GLSL_PATH"]}, " (default path value is ", {"type": "code", "text": ["HOUDINI_PATH/glsl"]}, " ). The files must have specific extensions - ", {"type": "code", "text": [".vert"]}, " for vertex shaders, ", {"type": "code", "text": [".geom"]}, " for geometry shaders, ", {"type": "code", "text": [".tcs"]}, " for tessellation control shaders (GL4.0+), ", {"type": "code", "text": [".tes"]}, " for tessellation evaluation shaders (GL4.0+) and ", {"type": "code", "text": [".frag"]}, " for fragment shaders."], "extent": [20650, 21001]}, {"type": "para", "indent": 0, "text": ["Finally, a comment can be specified on a line by starting it with ", {"type": "code", "text": ["//"]}, " . Comments cannot be specified on the same line as a directive or shader filename."], "extent": [21001, 21157]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Troubleshooting"], "extent": [21157, 21179], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["My Geometry is Invisible"], "extent": [21179, 21206], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["Some GLSL shaders require vertex attributes to be passed to them (e.g. the tangent space normal mapping shader). Make sure you are passing it the correct data."], "extent": [21206, 21372]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["The vertex position is not being calculated properly. "], "extent": [21372, 21434]}], "container": true}], "container": true}, {"type": "dt", "indent": 0, "text": ["My Geometry is drawn with red stripes"], "extent": [21434, 21473], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["Make sure that your GLSL shader compiles. The red stripes indicate that the shader could not be linked properly."], "extent": [21473, 21597]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["Right click the shader node and choose ", {"type": "ui", "text": ["Type properties"]}, ". Click the ", {"type": "ui", "text": ["Code"]}, " tab. Click ", {"type": "ui", "text": ["Test compile"]}, " to try compiling your shader code and check for errors."], "extent": [21597, 21776]}], "container": true}], "container": true}, {"type": "dt", "indent": 0, "text": ["My Geometry is Not Receiving Shadows"], "extent": [21776, 21814], "body": [{"type": "para", "indent": 4, "text": ["Some shaders emit light and don\u2019t reflect light (e.g. the decal shader). Such a shader will, by design, not receive shadows."], "extent": [21814, 21944]}], "container": true}], "container": true}]}], "title": ["Writing a custom viewport shader in GLSL"]}